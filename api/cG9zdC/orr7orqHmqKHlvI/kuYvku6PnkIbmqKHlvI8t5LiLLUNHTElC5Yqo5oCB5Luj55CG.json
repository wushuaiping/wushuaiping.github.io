{"title":"设计模式之代理模式(下) CGLIB动态代理","date":"2018-03-14T14:45:35.000Z","slug":"设计模式之代理模式-下-CGLIB动态代理","comments":true,"tags":["设计模式"],"updated":"2019-05-11T17:12:56.177Z","content":"<h1 id=\"CGLIB动态代理\">CGLIB动态代理<a href=\"post/设计模式之代理模式-下-CGLIB动态代理#CGLIB动态代理\"></a></h1><ul>\n<li>CGLIB动态代理非常强大、性能还挺厉害(<a href=\"http://blog.csdn.net/u010154380/article/details/58144370]\" target=\"_blank\" rel=\"noopener\">点这里查看JDK与CGLIB的性能对比(引用)</a>)。</li>\n<li>它的主要原理是：CGLIB通过字节码技术动态的生成业务类的子类，覆盖业务类的方法。并进行代理，因为采用的是继承方式，所以无法使用对final修饰的类进行代理。</li>\n</ul>\n<p>光看原理肯定还是不是那么了解的，所以我们还是来写代码吧！</p>\n<blockquote>\n<p>首先编写一个业务类<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 人员信息服务</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> wushuaiping</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2018/3/14 下午10:44</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EmployeeServiceImpl</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(Employee employee)</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"我调用了业务方法往数据库插入了一条数据~\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p>再编写CGLIB动态代理的代码</p>\n<blockquote>\n<ol>\n<li>首先需要去实现MethodInterceptor 方法拦截器。提供了intercept，方便在目标方法上进行切入。</li>\n<li>再写一个获取代理对象的方法，该方法中需要使用到Enhancer，CGLIB通过该增强器底层的字节码技术生成业务类的子类。并创建该子类的对象。<br>除了通过enhancer.create()通过无参构造器创建业务类代理对象以外；还可以使用enhancer.create(Class[] argumentTypes, Object[] arguments)通过有参构造器来创建对象。具体方式<a href=\"http://doc.okbase.net/1866821/archive/122803.html\" target=\"_blank\" rel=\"noopener\">请点击(引用)</a><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  CGLIB动态代理</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> wushuaiping</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2018/3/14 下午10:50</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CGLIBProxy</span> <span class=\"keyword\">implements</span> <span class=\"title\">MethodInterceptor</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object target;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">newInstance</span><span class=\"params\">(Object object)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.target = object;</span><br><span class=\"line\">        <span class=\"comment\">// 增强器</span></span><br><span class=\"line\">        Enhancer enhancer = <span class=\"keyword\">new</span> Enhancer();</span><br><span class=\"line\">        <span class=\"comment\">/* 生成被代理业务类(EmployeeServiceImpl)的子类;</span></span><br><span class=\"line\"><span class=\"comment\">         * 就是因为这里继承的关系，被代理业务类就不能使用final修饰。</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        enhancer.setSuperclass(<span class=\"keyword\">this</span>.target.getClass());</span><br><span class=\"line\">        <span class=\"comment\">// 被代理业务类所有方法都会通过这里来调用</span></span><br><span class=\"line\">        enhancer.setCallback(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 创建代理对象 这个是创建无参构造器代理对象的方式</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> enhancer.create();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">intercept</span><span class=\"params\">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">        before();</span><br><span class=\"line\">        <span class=\"comment\">// 去调用父类中的方法</span></span><br><span class=\"line\">        methodProxy.invokeSuper(o, objects);</span><br><span class=\"line\">        after();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">before</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"操作前的日志记录~~\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">after</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"操作后的日志记录~~\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>Test case</p>\n<blockquote>\n<ol>\n<li>先后创建代理对象以及被代理的业务类对象</li>\n<li>然后使用代理对象调用newInstance获取业务类代理类的对象。</li>\n<li>调用业务类代理对象的业务方法<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        CGLIBProxy proxy = <span class=\"keyword\">new</span> CGLIBProxy();</span><br><span class=\"line\">        EmployeeServiceImpl employeeService = <span class=\"keyword\">new</span> EmployeeServiceImpl();</span><br><span class=\"line\">        EmployeeServiceImpl proxySer = (EmployeeServiceImpl)proxy.newInstance(employeeService);</span><br><span class=\"line\">        proxySer.insert(<span class=\"keyword\">new</span> Employee());</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>运行结果<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">操作前的日志记录~~</span><br><span class=\"line\">我调用了业务方法往数据库插入了一条数据~</span><br><span class=\"line\">操作后的日志记录~~</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<h3 id=\"来讲讲优缺点吧：\">来讲讲优缺点吧：<a href=\"post/设计模式之代理模式-下-CGLIB动态代理#来讲讲优缺点吧：\"></a></h3><ul>\n<li>CGLIB的功能还是蛮强大的，可以不用实现接口也可进行动态代理。但是缺点也很明显，因为底层通过继承业务类的方式来进行代理，所以业务类不能使用final修饰。</li>\n</ul>\n","prev":{"title":"使用Socket&反射&Java流操作进行方法的远程调用(模拟RPC远程调用)","slug":"使用Socket-反射-Java流操作进行方法的远程调用-模拟RPC远程调用"},"next":{"title":"设计模式之代理模式(上) 静态代理与JDK动态代理","slug":"设计模式之代理模式-上-静态代理与JDK动态代理"},"link":"http://wooo.io/post/设计模式之代理模式-下-CGLIB动态代理/","toc":[{"title":"CGLIB动态代理","id":"CGLIB动态代理","index":"1"}]}