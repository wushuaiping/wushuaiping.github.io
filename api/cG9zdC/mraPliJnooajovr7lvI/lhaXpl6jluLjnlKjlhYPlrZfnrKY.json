{"title":"正则表达式入门常用元字符","date":"2018-04-17T05:29:00.000Z","slug":"正则表达式入门常用元字符","comments":true,"tags":["正则表达式"],"updated":"2019-05-11T17:14:35.246Z","content":"<h2 id=\"常用元字符\">常用元字符<a href=\"post/正则表达式入门常用元字符#常用元字符\"></a></h2><ul>\n<li>例子: hi, what are you doing? candy? </li>\n</ul>\n<h4 id=\"b-匹配单词的开始处或结尾处\"><code>\\b</code> 匹配单词的开始处或结尾处<a href=\"post/正则表达式入门常用元字符#b-匹配单词的开始处或结尾处\"></a></h4><p>如何正确的匹配<code>hi</code>？我们可以使用<code>\\bhi</code>来匹配，但是如果要匹配的单词是: <code>him,high,hidden</code>等单词，那么使用<code>\\bhi</code>就不能精确匹配出<code>hi</code>，所以我们可以使用<code>\\bhi\\b</code>该方式精确匹配出<code>hi</code>，该正则表达式理解为，匹配以h开始并且以i结束的词。</p>\n<h4 id=\"匹配除了换行符以外的任意字符\"><code>.</code> 匹配除了换行符以外的任意字符<a href=\"post/正则表达式入门常用元字符#匹配除了换行符以外的任意字符\"></a></h4><p>上面的列子精确的匹配了<code>hi</code>，但是现在又新增一个需求，想要匹配<code>hi</code>以及后面的<code>candy</code>。于是想到了使用<code>\\bhi\\b.\\bcandy\\b</code>来匹配，但是该语法有个限制，只能匹配一个字符，比如只能匹配<code>hi,candy、hi1candy</code>这种类似的字符，但无法匹配<code>hi, what are you doing? candy?</code>这样的字符，匹配的数量有限制。</p>\n<p> <span id=\"jump\"></span></p>\n<p>为了解决<code>.</code>只能一个任意字符的问题，我们可以将<code>*</code>与<code>.</code>联合使用，写出这样的表达式<code>\\bhi\\b.*\\bcandy\\b</code>，该表达式语义为： 匹配以<code>h</code>开头<code>i</code>结尾且中间为除换行符以外的任意字符，且可连续匹配该字符任意次，之后以<code>cand</code>开始以<code>y</code>结束的内容。</p>\n<h4 id=\"d-匹配数字\"><code>\\d</code> 匹配数字<a href=\"post/正则表达式入门常用元字符#d-匹配数字\"></a></h4><p>现在我们有一个需求，要求匹配以<code>15</code>开头的手机号，如:<code>15XXXXXXXXX</code><br>我们可以使用<code>\\d</code>写出<code>15\\d\\d\\d\\d\\d\\d\\d\\d\\d</code>这样的表达式。但是这样写比较麻烦；我们可以改成这样: <code>15\\d{9}</code>，该表达式表示: 匹配15之后的任意9个数字。</p>\n<h4 id=\"匹配字符串的开始处，-匹配字符串的结束处。\"><code>^</code>匹配字符串的开始处，$ 匹配字符串的结束处。<a href=\"post/正则表达式入门常用元字符#匹配字符串的开始处，-匹配字符串的结束处。\"></a></h4><p>上面的例子虽然可以匹配15开头的手机号，但是如果我们输入<code>as15111111111sd</code>这样的也能被匹配到，是因为我们没有做限制，现在我们就对上面的表达式改进为: <code>^15\\d{9}$</code></p>\n<h4 id=\"解除元字符限制\">解除元字符限制<a href=\"post/正则表达式入门常用元字符#解除元字符限制\"></a></h4><p>当我们想使用元字符本身的时候，可以使用<code>\\</code>对元字符进行转义，比如我相匹配<code>www.baidu.com</code>，我们可以使用<code>www\\.baidu\\.com</code>进行转义匹配，此外还比如匹配计算机盘符:<code>D:\\\\User</code>对应的是<code>D:\\User</code>。其他元字符也是如此: 比如使用<code>*</code>可以换成<code>\\*</code>等</p>\n<h2 id=\"限定符\">限定符<a href=\"post/正则表达式入门常用元字符#限定符\"></a></h2><h4 id=\"前面的内容可以连续重复0次或任意次数，最终使得整个表达式得以匹配\"><code>*</code> 前面的内容可以连续重复0次或任意次数，最终使得整个表达式得以匹配<a href=\"post/正则表达式入门常用元字符#前面的内容可以连续重复0次或任意次数，最终使得整个表达式得以匹配\"></a></h4><p> 上面已经有例子讲过的例子: <a href=\"#jump\">用*进行匹配</a></p>\n<h4 id=\"前面的内容可以连续重复至少1次或任意次数，最终使得整个表达式得以匹配\"><code>+</code> 前面的内容可以连续重复至少1次或任意次数，最终使得整个表达式得以匹配<a href=\"post/正则表达式入门常用元字符#前面的内容可以连续重复至少1次或任意次数，最终使得整个表达式得以匹配\"></a></h4><p> 使用<code>hi, what are you doing? candy?</code>的例子，我们要匹配包含<code>hi</code>开始，并以<code>candy</code>结束的单词。可以这样写: <code>^\\bhi\\b.+\\bcandy\\b$</code>。该表达式可以匹配<code>hi, what are you doing? candy?</code>这样的词组，但是无法匹配<code>hicandy</code>这样的词组。因为<code>+</code>的规则是至少是匹配重复的1次。<br> 如果要匹配数字呢？比如匹配<code>15</code>开头的数据,可以这样写:<code>15\\d+</code>。</p>\n","prev":{"title":"Spring Cloud踩坑记录","slug":"Spring-Cloud踩坑记录"},"next":{"title":"使用Socket&反射&Java流操作进行方法的远程调用(模拟RPC远程调用)","slug":"使用Socket-反射-Java流操作进行方法的远程调用-模拟RPC远程调用"},"link":"http://wooo.io/post/正则表达式入门常用元字符/","toc":[{"title":"常用元字符","id":"常用元字符","index":"1"},{"title":"限定符","id":"限定符","index":"2"}]}